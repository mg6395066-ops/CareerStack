import { Request, Response, NextFunction } from 'express';\nimport { logger } from '../utils/logger';\n\n/**\n * Comprehensive error handling middleware\n * Hides sensitive stack traces in production\n * Logs detailed errors for debugging\n */\n\ninterface ErrorResponse {\n  error: string;\n  message: string;\n  statusCode: number;\n  requestId?: string;\n  timestamp: string;\n  // Only in development:\n  stack?: string;\n  details?: any;\n}\n\nclass AppError extends Error {\n  constructor(\n    public statusCode: number = 500,\n    message: string = 'Internal Server Error',\n    public isOperational: boolean = true\n  ) {\n    super(message);\n    Error.captureStackTrace(this, this.constructor);\n  }\n}\n\n/**\n * Global error handling middleware\n * Must be registered last in middleware chain\n */\nexport const globalErrorHandler = (\n  err: Error | AppError,\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => {\n  const timestamp = new Date().toISOString();\n  const requestId = (req as any).id || 'unknown';\n\n  // Default error response\n  let errorResponse: ErrorResponse = {\n    error: 'InternalServerError',\n    message: 'An unexpected error occurred',\n    statusCode: 500,\n    requestId,\n    timestamp,\n  };\n\n  // Handle custom AppError\n  if (err instanceof AppError) {\n    errorResponse = {\n      error: err.name,\n      message: err.message,\n      statusCode: err.statusCode,\n      requestId,\n      timestamp,\n    };\n  }\n  // Handle known error types\n  else if (err instanceof SyntaxError && 'body' in err) {\n    errorResponse = {\n      error: 'BadRequest',\n      message: 'Invalid JSON in request body',\n      statusCode: 400,\n      requestId,\n      timestamp,\n    };\n  } else if (err instanceof TypeError) {\n    errorResponse = {\n      error: 'BadRequest',\n      message: 'Invalid request format',\n      statusCode: 400,\n      requestId,\n      timestamp,\n    };\n  }\n  // Unhandled error\n  else {\n    errorResponse = {\n      error: 'InternalServerError',\n      message: 'An unexpected error occurred',\n      statusCode: 500,\n      requestId,\n      timestamp,\n    };\n  }\n\n  // In development, include stack trace and details\n  if (process.env.NODE_ENV === 'development') {\n    errorResponse.stack = err.stack;\n    errorResponse.details = {\n      originalMessage: err.message,\n      name: err.name,\n    };\n  }\n\n  // Log error for debugging and monitoring\n  const logLevel = errorResponse.statusCode >= 500 ? 'error' : 'warn';\n  logger[logLevel]({\n    requestId,\n    error: err.message,\n    stack: err.stack,\n    statusCode: errorResponse.statusCode,\n    path: req.path,\n    method: req.method,\n    ip: req.ip,\n  });\n\n  // Send error response\n  res.status(errorResponse.statusCode).json(errorResponse);\n};\n\n/**\n * Validation error handler\n * Formats validation errors from Zod or other validators\n */\nexport const validationErrorHandler = (\n  err: any,\n  req: Request,\n  res: Response,\n  next: NextFunction\n) => {\n  if (err.name === 'ZodError' || (err.errors && Array.isArray(err.errors))) {\n    const errors = err.errors || [];\n    const errorMessage = errors\n      .map((e: any) => `${e.path?.join('.')}: ${e.message}`)\n      .join(', ') || 'Validation failed';\n\n    logger.warn({\n      type: 'ValidationError',\n      path: req.path,\n      errors: errorMessage,\n      ip: req.ip,\n    });\n\n    return res.status(400).json({\n      error: 'ValidationError',\n      message: 'Validation failed',\n      statusCode: 400,\n      timestamp: new Date().toISOString(),\n      ...(process.env.NODE_ENV === 'development' && {\n        details: errors,\n      }),\n    });\n  }\n\n  next(err);\n};\n\n/**\n * Not found handler\n * Should be registered after all routes\n */\nexport const notFoundHandler = (req: Request, res: Response) => {\n  logger.warn({\n    type: 'NotFound',\n    path: req.path,\n    method: req.method,\n    ip: req.ip,\n  });\n\n  res.status(404).json({\n    error: 'NotFound',\n    message: `Route ${req.method} ${req.path} not found`,\n    statusCode: 404,\n    timestamp: new Date().toISOString(),\n  });\n};\n\n/**\n * Async error wrapper\n * Wraps async route handlers to catch errors\n */\nexport const asyncHandler = (\n  fn: (req: Request, res: Response, next: NextFunction) => Promise<any>\n) => {\n  return (req: Request, res: Response, next: NextFunction) => {\n    Promise.resolve(fn(req, res, next)).catch(next);\n  };\n};\n\n/**\n * Custom error creation helpers\n */\nexport const createError = {\n  badRequest: (message: string) => new AppError(400, message, true),\n  unauthorized: (message: string = 'Unauthorized') => new AppError(401, message, true),\n  forbidden: (message: string = 'Access denied') => new AppError(403, message, true),\n  notFound: (message: string = 'Resource not found') => new AppError(404, message, true),\n  conflict: (message: string) => new AppError(409, message, true),\n  unprocessable: (message: string) => new AppError(422, message, true),\n  tooManyRequests: (message: string = 'Too many requests') => new AppError(429, message, true),\n  internalError: (message: string = 'Internal server error') => new AppError(500, message, true),\n  serviceUnavailable: (message: string = 'Service unavailable') => new AppError(503, message, true),\n};\n\nexport default {\n  globalErrorHandler,\n  validationErrorHandler,\n  notFoundHandler,\n  asyncHandler,\n  createError,\n  AppError,\n};\n